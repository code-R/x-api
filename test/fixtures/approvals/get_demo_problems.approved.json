{
  "assignments": [
    {
      "track_id": "clojure",
      "id": "bob",
      "track": "clojure",
      "slug": "bob",
      "files": {
        "bob_test.clj": "(ns bob-test\n  (:require [clojure.test :refer :all]))\n\n(load-file \"bob.clj\")\n\n(deftest responds-to-something\n  (is (= \"Whatever.\" (bob/response-for \"Tom-ay-to, tom-aaaah-to.\"))))\n\n(deftest responds-to-shouts\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WATCH OUT!\"))))\n\n(deftest responds-to-questions\n  (is (= \"Sure.\" (bob/response-for \"Does this cryogenic chamber make me look fat?\"))))\n\n(deftest responds-to-forceful-talking\n  (is (= \"Whatever.\" (bob/response-for \"Let's go make out behind the gym!\"))))\n\n(deftest responds-to-acronyms\n  (is (= \"Whatever.\" (bob/response-for \"It's OK if you don't want to go to the DMV.\"))))\n\n(deftest responds-to-forceful-questions\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WHAT THE HELL WERE YOU THINKING?\"))))\n\n(deftest responds-to-shouting-with-special-characters\n  (is (= \"Whoa, chill out!\" (bob/response-for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"))))\n\n(deftest responds-to-shouting-numbers\n  (is (= \"Whoa, chill out!\" (bob/response-for \"1, 2, 3 GO!\"))))\n\n(deftest responds-to-shouting-with-no-exclamation-mark\n  (is (= \"Whoa, chill out!\" (bob/response-for \"I HATE YOU\"))))\n\n(deftest responds-to-statement-containing-question-mark\n  (is (= \"Whatever.\" (bob/response-for \"Ending with ? means a question.\"))))\n\n(deftest responds-to-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"\"))))\n\n(deftest responds-to-prolonged-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"    \"))))\n\n(deftest responds-to-only-numbers\n  (is (= \"Whatever.\" (bob/response-for \"1, 2, 3\"))))\n\n(deftest responds-to-number-question\n  (is (= \"Sure.\" (bob/response-for \"4?\"))))\n\n(run-tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "coffeescript",
      "id": "bob",
      "track": "coffeescript",
      "slug": "bob",
      "files": {
        "bob_test.spec.coffee": "Bob = require \"./bob\"\ndescribe \"Bob\", ->\n  bob = new Bob()\n  it \"stating something\", ->\n    result = bob.hey \"Tom-ay-to, tom-aaaah-to.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"shouting\", ->\n    result = bob.hey \"WATCH OUT!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"asking a question\", ->\n    result = bob.hey \"Does this cryogenic chamber make me look fat?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"talking forcefully\", ->\n    result = bob.hey \"Let's go make out behind the gym!\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"using acronyms in regular speech\", ->\n    result = bob.hey \"It's OK if you don't want to go to the DMV.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"forceful questions\", ->\n    result = bob.hey \"WHAT THE HELL WERE YOU THINKING?\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"shouting numbers\", ->\n    result = bob.hey \"1, 2, 3 GO!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"only number\", ->\n    result = bob.hey \"1, 2, 3\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"shouting with special characters\", ->\n    result = bob.hey \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"shouting with no exclamation mark\", ->\n    result = bob.hey \"I HATE YOU\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"statement containing question mark\", ->\n    result = bob.hey \"Ending with a ? means a question.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"prattling on\", ->\n    result = bob.hey \"Wait! Hang on.  Are you going to be OK?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"silence\", ->\n    result = bob.hey \"\"\n    expect(result).toEqual \"Fine. Be that way!\"\n\n  xit \"prolonged silence\", ->\n    result = bob.hey \"   \"\n    expect(result).toEqual \"Fine. Be that way!\"\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "cpp",
      "id": "bob",
      "track": "cpp",
      "slug": "bob",
      "files": {
        "CMakeLists.txt": "# Get the exercise name from the current directory\nget_filename_component(exercise ${CMAKE_CURRENT_SOURCE_DIR} NAME)\n\n# Basic CMake project\ncmake_minimum_required(VERSION 2.8.11)\n\n# Name the project after the exercise\nproject(${exercise} CXX)\n\n# Locate Boost libraries: unit_test_framework, date_time and regex\nset(Boost_USE_STATIC_LIBS ON)\nset(Boost_USE_MULTITHREADED ON)\nset(Boost_USE_STATIC_RUNTIME OFF)\nfind_package(Boost 1.55 REQUIRED COMPONENTS unit_test_framework date_time regex)\n\n# Enable C++11 features on gcc/clang\nif(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(GNU|Clang)\")\n    set(CMAKE_CXX_FLAGS \"-std=c++11\")\nendif()\n\n# Configure to run all the tests?\nif(${EXERCISM_RUN_ALL_TESTS})\n    add_definitions(-DEXERCISM_RUN_ALL_TESTS)\nendif()\n\n# Get a source filename from the exercise name by replacing -'s with _'s\nstring(REPLACE \"-\" \"_\" file ${exercise})\n\n# Implementation could be only a header\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${file}.cpp)\n    set(exercise_cpp ${file}.cpp)\nelse()\n    set(exercise_cpp \"\")\nendif()\n\n# Build executable from sources and headers\nadd_executable(${exercise} ${file}_test.cpp ${exercise_cpp} ${file}.h)\n\n# We need boost includes\ntarget_include_directories(${exercise} PRIVATE ${Boost_INCLUDE_DIRS})\n\n# We need boost libraries\ntarget_link_libraries(${exercise} ${Boost_LIBRARIES})\n\n# Tell MSVC not to warn us about unchecked iterators in debug builds\nif(${MSVC})\n    set_target_properties(${exercise} PROPERTIES\n        COMPILE_DEFINITIONS_DEBUG _SCL_SECURE_NO_WARNINGS)\nendif()\n\n# Run the tests on every build\nadd_custom_command(TARGET ${exercise} POST_BUILD COMMAND ${exercise})\n",
        "bob_test.cpp": "#include \"bob.h\"\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n\nBOOST_AUTO_TEST_CASE(stating_something)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Tom-ay-to, tom-aaaah-to.\"));\n}\n\n#if defined(EXERCISM_RUN_ALL_TESTS)\nBOOST_AUTO_TEST_CASE(shouting)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WATCH OUT!\"));\n}\n\nBOOST_AUTO_TEST_CASE(asking_a_question)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Does this cryogenic chamber make me look fat?\"));\n}\n\nBOOST_AUTO_TEST_CASE(talking_forcefully)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Let's go make out behind the gym!\"));\n}\n\nBOOST_AUTO_TEST_CASE(using_acronyms_in_regular_speech)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"It's OK if you don't want to go to the DMV.\"));\n}\n\nBOOST_AUTO_TEST_CASE(forceful_questions)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WHAT THE HELL WERE YOU THINKING?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"1, 2, 3 GO!\"));\n}\n\nBOOST_AUTO_TEST_CASE(only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"1, 2, 3\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"4?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_special_characters)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_no_exclamation_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"I HATE YOU\"));\n}\n\nBOOST_AUTO_TEST_CASE(statement_containing_question_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Ending with a ? means a question.\"));\n}\n\nBOOST_AUTO_TEST_CASE(prattling_on)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Wait! Hang on.  Are you going to be OK?\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_trailing_whitespace)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Are you ok? \"));\n}\n\nBOOST_AUTO_TEST_CASE(silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"\"));\n}\n\nBOOST_AUTO_TEST_CASE(prolonged_silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"   \"));\n}\n#endif\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Getting Started\n\nMake sure you have read the [getting started with C++](http://help.exercism.io/getting-started-with-cpp.html)\npage on the [exercism help site](http://help.exercism.io/).  This covers\nthe basic information on setting up the development environment expected\nby the exercises.\n\n## Passing the Tests\n\nGet the first test compiling, linking and passing by following the [three\nrules of test-driven development](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd).\nCreate just enough structure by declaring namespaces, functions, classes,\netc., to satisfy any compiler errors and get the test to fail.  Then write\njust enough code to get the test to pass.  Once you've done that,\nuncomment the next test by moving the following line past the next test.\n\n```C++\n#if defined(EXERCISM_RUN_ALL_TESTS)\n```\n\nThis may result in compile errors as new constructs may be invoked that\nyou haven't yet declared or defined.  Again, fix the compile errors minimally\nto get a failing test, then change the code minimally to pass the test,\nrefactor your implementation for readability and expressiveness and then\ngo on to the next test.\n\nTry to use standard C++11 facilities in preference to writing your own\nlow-level algorithms or facilities by hand.  [CppReference](http://en.cppreference.com/)\nis a wiki reference to the C++ language and standard library.  If you\nare new to C++, but have programmed in C, beware of\n[C traps and pitfalls](http://www.slideshare.net/LegalizeAdulthood/c-traps-and-pitfalls-for-c-programmers).\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "csharp",
      "id": "leap",
      "track": "csharp",
      "slug": "leap",
      "files": {
        "LeapTest.cs": "using NUnit.Framework;\n\n[TestFixture]\npublic class LeapTest\n{\n    [Test]\n    public void Valid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1996), Is.True);\n    }\n\n    [Ignore]\n    [Test]\n    public void Invalid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1997), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_20th_century_is_not_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(1900), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_25th_century_is_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(2400), Is.True);\n    }\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure you're exercise file you're submitting is in the `exercism/csharp/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.cs` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/csharp/bob/bob.cs`.\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "elixir",
      "id": "bob",
      "track": "elixir",
      "slug": "bob",
      "files": {
        "bob.exs": "defmodule Teenager do\n  def hey(input) do\n    cond do\n\n    end\n  end\nend\n",
        "bob_test.exs": "if System.get_env(\"EXERCISM_TEST_EXAMPLES\") do\n  Code.load_file(\"example.exs\")\nelse\n  Code.load_file(\"bob.exs\")\nend\n\nExUnit.start\n\ndefmodule TeenagerTest do\n  use ExUnit.Case, async: true\n\n  test \"stating something\" do\n    assert Teenager.hey(\"Tom-ay-to, tom-aaaah-to.\") == \"Whatever.\"\n  end\n\n  test \"shouting\" do\n    # assert Teenager.hey(\"WATCH OUT!\") == \"Whoa, chill out!\"\n  end\n\n  test \"asking a question\" do\n    # assert Teenager.hey(\"Does this cryogenic chamber make me look fat?\") == \"Sure.\"\n  end\n\n  test \"talking forcefully\" do\n    # assert Teenager.hey(\"Let's go make out behind the gym!\") == \"Whatever.\"\n  end\n\n  test \"talking in capitals\" do\n    # assert Teenager.hey(\"This Isn't Shouting!\") == \"Whatever.\"\n  end\n\n  test \"shouting numbers\" do\n    # assert Teenager.hey(\"1, 2, 3 GO!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with special characters\" do\n    # assert Teenager.hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with no exclamation mark\" do\n    # assert Teenager.hey(\"I HATE YOU\") == \"Whoa, chill out!\"\n  end\n\n  test \"statement containing question mark\" do\n    # assert Teenager.hey(\"Ending with ? means a question.\") == \"Whatever.\"\n  end\n\n  test \"silence\" do\n    # assert Teenager.hey(\"\") == \"Fine. Be that way!\"\n  end\n\n  test \"prolonged silence\" do\n    # assert Teenager.hey(\"  \") == \"Fine. Be that way!\"\n  end\n\n  test \"only numbers\" do\n    # assert Teenager.hey(\"1, 2, 3\") == \"Whatever.\"\n  end\n\n  test \"question with numbers\" do\n    # assert Teenager.hey(\"4?\") == \"Sure.\"\n  end\n\n  test \"shouting in Russian\" do\n    # Hopefully this is Russian for \"get out\"\n    # assert Teenager.hey(\"УХОДИТЬ\") == \"Whoa, chill out!\"\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "erlang",
      "id": "leap",
      "track": "erlang",
      "slug": "leap",
      "files": {
        "leap_tests.erl": "% To run tests:\n% erl -make\n% erl -noshell -eval \"eunit:test(leap, [verbose])\" -s init stop\n%\n\n-module(leap_tests).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\nleap_year_test() ->\n    ?assert(leap:leap_year(1996)).\n\nnon_leap_year_test() ->\n    ?assertNot(leap:leap_year(1997)).\n\ncentury_test() ->\n    ?assertNot(leap:leap_year(1900)).\n\nfourth_century_test() ->\n    ?assert(leap:leap_year(2400)).\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "fsharp",
      "id": "sum-of-multiples",
      "track": "fsharp",
      "slug": "sum-of-multiples",
      "files": {
        "SumOfMultiplesTest.fs": "﻿module SumOfMultiplesTest\n\nopen NUnit.Framework\nopen SumOfMultiples\n\n[<TestFixture>]\ntype SumOfMultiplesTest() =\n    let mutable sumOfMultiples = SumOfMultiples()\n    \n    [<Test>]\n    member tc.Sum_to_1() = \n        Assert.That(sumOfMultiples.To(0), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_3() = \n        Assert.That(sumOfMultiples.To(3), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_10() = \n        Assert.That(sumOfMultiples.To(10), Is.EqualTo(23))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_7_13_17_to_20() = \n        Assert.That(SumOfMultiples([7; 13; 17]).To(20), Is.EqualTo(51))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_43_47_to_10000() = \n        Assert.That(SumOfMultiples([43; 47]).To(10000), Is.EqualTo(2203160))",
        "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of 3 or 5 up to but not including that number.\n\nIf we list all the natural numbers below 10 that are multiples of 3 or\n5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nAllow the program to be configured to find the sum of multiples of\nnumbers other than 3 and 5.\n\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
      },
      "fresh": false
    },
    {
      "track_id": "go",
      "id": "leap",
      "track": "go",
      "slug": "leap",
      "files": {
        "cases_test.go": "package leap\n\n// Source: exercism/x-common\n// Commit: 945d08e Merge pull request #50 from soniakeys/master\n\nvar testCases = []struct {\n\tyear        int\n\texpected    bool\n\tdescription string\n}{\n\t{1996, true, \"leap year\"},\n\t{1997, false, \"non-leap year\"},\n\t{1998, false, \"non-leap even year\"},\n\t{1900, false, \"century\"},\n\t{2400, true, \"fourth century\"},\n\t{2000, true, \"Y2K\"},\n}\n",
        "leap_test.go": "package leap\n\nimport \"testing\"\n\n// Define a function IsLeapYear(int) bool.\n//\n// Also define an exported TestVersion with a value that matches\n// the internal testVersion here.\n\nconst testVersion = 1\n\n// Retired testVersions\n// (none) 4a9e144a3c5dc0d9773f4cf641ffe3efe48641d8\n\nfunc TestLeapYears(t *testing.T) {\n\tif TestVersion != testVersion {\n\t\tt.Fatalf(\"Found TestVersion = %v, want %v\", TestVersion, testVersion)\n\t}\n\tfor _, test := range testCases {\n\t\tobserved := IsLeapYear(test.year)\n\t\tif observed != test.expected {\n\t\t\tt.Fatalf(\"IsLeapYear(%d) = %t, want %t (%s)\",\n\t\t\t\ttest.year, observed, test.expected, test.description)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLeapYears(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range testCases {\n\t\t\tIsLeapYear(test.year)\n\t\t}\n\t}\n}\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "leap",
      "track": "haskell",
      "slug": "leap",
      "files": {
        "leap_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport LeapYear (isLeapYear)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList isLeapYearTests ]\n\nisLeapYearTests :: [Test]\nisLeapYearTests =\n  [ testCase \"vanilla leap year\" $\n    True @=? isLeapYear 1996\n  , testCase \"any old year\" $\n    False @=? isLeapYear 1997\n  , testCase \"century\" $\n    False @=? isLeapYear 1900\n  , testCase \"exceptional century\" $\n    True @=? isLeapYear 2400\n  ]\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "java",
      "id": "etl",
      "track": "java",
      "slug": "etl",
      "files": {
        "build.gradle": "apply plugin: \"java\"\napply plugin: \"eclipse\"\napply plugin: \"idea\"\n\nrepositories {\n  mavenCentral()\n}\n\ndependencies {\n  testCompile \"junit:junit:4.10\"\n  testCompile \"org.easytesting:fest-assert-core:2.0M10\"\n  testCompile \"com.google.guava:guava:16+\"\n}\n",
        "src/main/java/Etl.java": "",
        "src/test/java/EtlTest.java": "import com.google.common.collect.ImmutableMap;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class EtlTest {\n    private final Etl etl = new Etl();\n\n    @Test\n    public void testTransformOneValue() {\n        Map<Integer, List<String>> old = ImmutableMap.of(1, Arrays.asList(\"A\"));\n        Map<String, Integer> expected = ImmutableMap.of(\"a\", 1);\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testTransformMoreValues() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"i\", 1,\n                \"o\", 1,\n                \"u\", 1\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testMoreKeys() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\"),\n                2, Arrays.asList(\"D\", \"G\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"d\", 2,\n                \"g\", 2\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testFullDataset() {\n        Map<Integer, List<String>> old = ImmutableMap.<Integer, List<String>>builder().\n                put(1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\")).\n                put(2, Arrays.asList(\"D\", \"G\")).\n                put(3, Arrays.asList(\"B\", \"C\", \"M\", \"P\")).\n                put(4, Arrays.asList(\"F\", \"H\", \"V\", \"W\", \"Y\")).\n                put(5, Arrays.asList(\"K\")).\n                put(8, Arrays.asList(\"J\", \"X\")).\n                put(10, Arrays.asList(\"Q\", \"Z\")).\n                build();\n        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder().\n                put(\"a\", 1).put(\"b\", 3).put(\"c\", 3).put(\"d\", 2).put(\"e\", 1).\n                put(\"f\", 4).put(\"g\", 2).put(\"h\", 4).put(\"i\", 1).put(\"j\", 8).\n                put(\"k\", 5).put(\"l\", 1).put(\"m\", 3).put(\"n\", 1).put(\"o\", 1).\n                put(\"p\", 3).put(\"q\", 10).put(\"r\", 1).put(\"s\", 1).put(\"t\", 1).\n                put(\"u\", 1).put(\"v\", 4).put(\"w\", 4).put(\"x\", 8).put(\"y\", 4).\n                put(\"z\", 10).build();\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n}\n",
        "README.md": "# Etl\n\nWe are going to do the `Transform` step of an Extract-Transform-Load.\n\n### ETL\nExtract-Transform-Load (ETL) is a fancy way of saying, \"We have some crufty, legacy data over in this system, and now we need it in this shiny new system over here, so\nwe're going to migrate this.\"\n\n(Typically, this is followed by, \"We're only going to need to run this\nonce.\" That's then typically followed by much forehead slapping and\nmoaning about how stupid we could possibly be.)\n\n### The goal\nWe're going to extract some scrabble scores from a legacy system.\n\nThe old system stored a list of letters per score:\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThe shiny new scrabble system instead stores the score per letter, which\nmakes it much faster and easier to calculate the score for a word. It\nalso stores the letters in lower-case regardless of the case of the\ninput letters:\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- Etc.\n\nYour mission, should you choose to accept it, is to write a program that\ntransforms the legacy data format to the shiny new format.\n\n### Notes\nNote that both the old and the new system use strings to represent\nletters, even in languages that have a separate data type for\ncharacters. \n\nA final note about scoring, Scrabble is played around the world in a\nvariety of languages, each with its own unique scoring table. For\nexample, an \"A\" is scored at 14 in the Basque-language version of the\ngame while being scored at 9 in the Latin-language version.\n\n\n## Source\n\nThe Jumpstart Lab team [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "track_id": "javascript",
      "id": "bob",
      "track": "javascript",
      "slug": "bob",
      "files": {
        "bob.js": "//\n// This is only a SKELETON file for the \"Bob\" exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nvar Bob = function() {};\n\nBob.prototype.hey = function(input) {\n//\n// YOUR CODE GOES HERE\n//\n};\n\nmodule.exports = Bob;\n",
        "bob_test.spec.js": "var Bob = require('./bob.js');\n\ndescribe(\"Bob\", function() {\n  var bob = new Bob();\n\n  it(\"stating something\", function() {\n    var result = bob.hey('Tom-ay-to, tom-aaaah-to.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting\", function() {\n    var result = bob.hey('WATCH OUT!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"asking a question\", function() {\n    var result = bob.hey('Does this cryogenic chamber make me look fat?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"talking forcefully\", function() {\n    var result = bob.hey(\"Let's go make out behind the gym!\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"using acronyms in regular speech\", function() {\n    var result = bob.hey(\"It's OK if you don't want to go to the DMV.\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"forceful questions\", function() {\n    var result = bob.hey('WHAT THE HELL WERE YOU THINKING?');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"shouting numbers\", function() {\n    var result = bob.hey('1, 2, 3 GO!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"only numbers\", function() {\n    var result = bob.hey('1, 2, 3');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"question with only numbers\", function() {\n    var result = bob.hey('4?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"shouting with special characters\", function() {\n    var result = bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"shouting with umlauts\", function() {\n    var result = bob.hey(\"\\xdcML\\xc4\\xdcTS!\");\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"calmly speaking about umlauts\", function() {\n    var result = bob.hey(\"\\xfcML\\xe4\\xdcTS\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting with no exclamation mark\", function () {\n    var result = bob.hey('I HATE YOU');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"statement containing question mark\", function() {\n    var result = bob.hey('Ending with a ? means a question.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"prattling on\", function () {\n    var result = bob.hey('Wait! Hang on.  Are you going to be OK?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"silence\", function () {\n    var result = bob.hey('');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n\n   xit(\"prolonged silence\", function () {\n    var result = bob.hey('   ');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n});\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Setup\n\nGo through the setup instructions for JavaScript to\ninstall the necessary dependencies:\n\nhttp://help.exercism.io/getting-started-with-javascript.html\n\n## Making the Test Suite Pass\n\nExecute the tests with:\n\n```bash\n$ jasmine-node .\n```\n\nIn many test suites all but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "lisp",
      "id": "point-mutations",
      "track": "lisp",
      "slug": "point-mutations",
      "files": {
        "dna.lisp": "(defpackage #:dna\n  (:use #:cl)\n  (:export #:hamming-distance))\n(in-package #:dna)\n\n(defun hamming-distance (dna1 dna2)\n  \"Determine number of mutations between DNA strands by computing the Hamming Distance.\"\n  )\n",
        "point-mutations-test.lisp": "(ql:quickload \"lisp-unit\")\n\n(defpackage #:point-mutations-test\n  (:use #:common-lisp #:lisp-unit))\n\n(load \"dna\")\n\n(in-package #:point-mutations-test)\n\n(define-test no-difference-between-empty-strands\n  (assert-equal 0 (dna:hamming-distance \"\" \"\")))\n\n(define-test no-difference-between-identical-strands\n  (assert-equal 0 (dna:hamming-distance \"GGACTGA\" \"GGACTGA\")))\n\n(define-test complete-hamming-distance-in-small-strand\n  (assert-equal 3 (dna:hamming-distance \"ACT\" \"GGA\")))\n\n(define-test small-hamming-distance-in-middle-somewhere\n  (assert-equal 1 (dna:hamming-distance \"GGACG\" \"GGTCG\")))\n\n(define-test larger-distance\n  (assert-equal 2 (dna:hamming-distance \"ACCAGGG\" \"ACTATGG\")))\n\n(define-test invalid-to-get-distance-for-different-length-strings\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGACATCTTTCAGCCGCCGGATTAGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGG\" \"AGACAACAGCCAGCCGCCGGATT\")))\n\n(let ((*print-errors* t)\n      (*print-failures* t))\n  (run-tests :all :point-mutations-test))\n",
        "README.md": "# Point Mutations\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. Hence you\nmay assume that only sequences of equal length will be passed to your hamming\ndistance function.\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "lua",
      "id": "hamming",
      "track": "lua",
      "slug": "hamming",
      "files": {
        "hamming_test.lua": "local compute = require('./hamming').compute\n\ndescribe('Hamming', function ()\n\n  it('no difference between identical strands', function ()\n     assert.are.equals(0, compute('A', 'A'))\n  end)\n\n  it('complete hamming distance of for single nucleotide strand', function ()\n     assert.are.equals(1, compute('A', 'G'))\n  end)\n\n  it('complete hamming distance of for small strand', function ()\n     assert.are.equals(2, compute('AG', 'CT'))\n  end)\n\n  it('small hamming distance', function ()\n     assert.are.equals(1, compute('AT', 'CT'))\n  end)\n\n  it('small hamming distance in longer strand', function ()\n     assert.are.equals(1, compute('GGACG', 'GGTCG'))\n  end)\n\n  it('ignores extra length on first strand when longer', function ()\n     assert.are.equals(0, compute('AAAG', 'AAA'))\n  end)\n\n  it('ignores extra length on other strand when longer', function ()\n     assert.are.equals(0, compute('AAA', 'AAAG'))\n  end)\n\n  it('large hamming distance', function ()\n     assert.are.equals(4, compute('GATACA', 'GCATAA'))\n  end)\n\n  it('hamming distance in very long strand', function ()\n     assert.are.equals(9, compute('GGACGGATTCTG', 'AGGACGGATTCT'))\n  end)\n\nend)\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n### Getting started\nFirst install lua using [homebrew][1]\n\n    $ brew install lua\n\nThen install [luarocks][2] to install packages for lua\n\n    $ brew install luarocks\n\nThen install [busted][3] testing framework for lua\n\n    $ luarocks install busted\n    \nThen run your test\n\n    $ busted bob_test.lua \n    \nOther resources\n\n  1. [Lua Style Guide][4]\n  2. [Learn Lua in 15 minutes][5] \n\n[1]: http://brew.sh/\n[2]: http://luarocks.org/\n[3]: http://olivinelabs.com/busted/\n[4]: https://github.com/Olivine-Labs/lua-style-guide\n[5]: http://tylerneylon.com/a/learn-lua/\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "objective-c",
      "id": "bob",
      "track": "objective-c",
      "slug": "bob",
      "files": {
        "BobTest.m": "#import <XCTest/XCTest.h>\n#import \"Bob.h\"\n\n@interface test_suite : XCTestCase\n\n@end\n\n@implementation test_suite\n\n- (Bob *)bob {\n  return [[Bob alloc] init];\n}\n\n- (void)testStatingSomething {\n  NSString *input = @\"Tom-ay-to, tom-aaaah-to.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShouting {\n  NSString *input = @\"WATCH OUT!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testAskingAQuestion {\n  NSString *input = @\"Does this cryogenic chamber make me look fat?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testTalkingForcefully {\n  NSString *input = @\"Let's go make out behind the gym!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testUsingAcronyms {\n  NSString *input = @\"It's OK if you don't want to go to the DMV.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testForcefulQuestions {\n  NSString *input = @\"WHAT THE HELL WERE YOU THINKING?\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingNumbers {\n  NSString *input = @\"1, 2, 3 GO!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testOnlyNumbers {\n  NSString *input = @\"1, 2, 3.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n- (void)testQuestionWithOnlyNumbers {\n  NSString *input = @\"4?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithSpecialCharacters {\n  NSString *input = @\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithUmlautsCharacters {\n  NSString *input = @\"ÄMLÄTS!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testCalmlySpeakingAboutUmlauts {\n  NSString *input = @\"ÄMLäTS!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithNoExclamationMark {\n  NSString *input = @\"I HATE YOU\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testStatementContainingQuestionsMark {\n  NSString *input = @\"Ending with a ? means a question.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testPrattlingOn {\n  NSString *input = @\"Wait! Hang on.  Are you going to be OK?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testSilence {\n  NSString *input = @\"\";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testProlongedSilence {\n  NSString *input = @\"     \";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n@end\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "ocaml",
      "id": "bob",
      "track": "ocaml",
      "slug": "bob",
      "files": {
        "Makefile": "test: test.native\n\t@./test.native\n\ntest.native: *.ml *.mli\n\t@corebuild -quiet test.native\n\nclean:\n\trm -rf _build\n\n.PHONY: clean\n",
        "bob.mli": "(*\nAnswers to `hey` like a teenager.\n\n## Examples\n\n  # response_for \"\"\n  \"Fine. Be that way!\"\n\n  # response_for \"Do you like math?\"\n  \"Sure.\"\n\n  # response_for \"HELLO!\"\n  \"Woah, chill out!\"\n\n  # response_for \"Coding is cool.\"\n  \"Whatever.\"\n*)\nval response_for : string -> string\n",
        "test.ml": "open Core.Std\nopen OUnit2\nopen Bob\n\nlet ae exp got _test_ctxt = assert_equal ~printer:String.to_string exp got\n\nlet tests =\n  [\"something\">::\n     ae \"Whatever.\" (response_for \"Tom-ay-to, tom-aaaah-to.\");\n   \"shouts\">::\n     ae \"Whoa, chill out!\" (response_for \"WATCH OUT!\");\n   \"questions\">::\n     ae \"Sure.\" (response_for \"Does this cryogenic chamber make me look fat?\");\n   \"forceful talking\">::\n     ae \"Whatever.\" (response_for \"Let's go make out behind the gym!\");\n   \"acronyms\">::\n     ae \"Whatever.\" (response_for \"It's ok if you don't want to go to the DMV.\");\n   \"forceful questions\">::\n     ae \"Whoa, chill out!\" (response_for \"WHAT THE HELL WERE YOU THINKING?\");\n   \"shouting with special characters\">::\n     ae \"Whoa, chill out!\"\n       (response_for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\");\n   \"shouting numbers\">::\n     ae \"Whoa, chill out!\" (response_for \"1, 2, 3, GO!\");\n   \"statement containing question mark\">::\n     ae \"Whatever.\" (response_for \"Ending with ? means a question.\");\n   \"silence\">::\n     ae \"Fine. Be that way!\" (response_for \"\");\n   \"prolonged silence\">::\n     ae \"Fine. Be that way!\" (response_for \"   \");\n   \"non-letters with question\">::\n     ae \"Sure.\" (response_for \":) ?\");\n   \"multiple line questons\">::\n     ae \"Whatever.\"\n       (response_for \"\\nDoes this cryogenic chamber make me look fat? \\nno\");\n   \"other whitespace\">::\n     (* No unicode whitespace as OCaml Core doesn't seem to handle Unicode.\n      * Not it seems does it see ASCII 11 (\\v) as whitespace.\n     *)\n     ae \"Fine. Be that way!\" (response_for \"\\n\\r \\t\");\n   \"only numbers\">::\n     ae \"Whatever.\" (response_for \"1, 2, 3\");\n   \"question with only numbers\">::\n     ae \"Sure.\" (response_for \"4?\");\n  ]\n\nlet () =\n  run_test_tt_main (\"bob tests\" >::: tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "perl5",
      "id": "bob",
      "track": "perl5",
      "slug": "bob",
      "files": {
        "bob.pm": "#\n# This is a SKELETON file and has been provided to enable you to get working on the\n# first exercise more quickly.\n#\n\nuse 5.006;\nuse strict;\nuse warnings;\n\npackage Bob;\n\nour $VERSION = '1.000';\n\nuse Exporter 5.57 qw(import);\n\nour @EXPORT_OK = qw(hey);\n\nsub hey {\n#\n# YOUR CODE GOES HERE\n#\n}\n\n1;\n",
        "bob.t": "use strict;\nuse warnings;\nuse open ':std', ':encoding(utf8)';\nuse utf8;\n\nmy $module = $ENV{EXERCISM} ? 'Example' : 'Bob';\n\nuse Test::More;\n\nmy @cases = map {\n    {\n        input   => $_->[0],\n        expect  => $_->[1],\n        desc    => $_->[2],\n    }\n} (\n    # input                                             expected output       title\n    ['Tom-ay-to, tom-aaaah-to.',                       'Whatever.',          'stating something'],\n    ['WATCH OUT!',                                     'Whoa, chill out!',   'shouting'],\n    ['Does this cryogenic chamber make me look fat?',  'Sure.',              'question'],\n    ['You are, what, like 15?',                        'Sure.',              'numeric question'],\n    [\"Let's go make out behind the gym!\",              'Whatever.',          'talking forcefully'],\n    [\"It's OK if you don't want to go to the DMV.\",    'Whatever.',          'using acronyms in regular speech'],\n    ['WHAT THE HELL WERE YOU THINKING?',               'Whoa, chill out!',   'forceful questions'],\n    ['1, 2, 3 GO!',                                    'Whoa, chill out!',   'shouting numbers'],\n    ['1, 2, 3',                                        'Whatever.',          'only numbers'],\n    ['4?',                                             'Sure.',              'question with only numbers'],\n    ['ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!',  'Whoa, chill out!',   'shouting with special characters'],\n    [\"ÜMLÄÜTS!\",                                       'Whoa, chill out!',   'shouting with umlauts'],\n    [\"\\xdcML\\xc4\\xdcTS!\",                              'Whoa, chill out!',   'shouting with umlauts'],\n    [\"ÜMLäÜTS!\",                                       'Whatever.',          'speaking calmly with umlauts'],\n    #[\"\\xdcML\\xe4\\xdcTS!\",                              'Whatever.',          'speaking calmly with umlauts'],\n    ['I HATE YOU',                                     'Whoa, chill out!',   'shouting with no exclamation mark'],\n    ['Ending with ? means a question.',                'Whatever.',          'statement containing question mark'],\n    [\"Wait! Hang on. Are you going to be OK?\",         'Sure.',              'prattling on'],\n    ['',                                               'Fine. Be that way!', 'silence'],\n    ['    ',                                           'Fine. Be that way!', 'prolonged silence'],\n);\n\nok -e \"$module.pm\", \"missing $module.pm\"\n    or BAIL_OUT(\"You need to create a module called $module.pm with a function called hey() that gets one parameter: The text Bob hears.\");\n\nuse_ok('Bob')\n    or BAIL_OUT(\"Does $module.pm compile?  Does it end with 1; ?\");\n\ncan_ok($module, 'hey')\n    or BAIL_OUT(\"Missing package $module; or missing sub hey()\");\n\nmy $sub = $module->can('hey');\n\nforeach my $c (@cases) {\n    #diag uc $c->{input};\n    my $title = $c->{desc} ? \"$c->{desc}: $c->{input}\" : $c->{input};\n    is $sub->( $c->{input} ), $c->{expect}, $title;\n}\n\ndone_testing();\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "plsql",
      "id": "hamming",
      "track": "plsql",
      "slug": "hamming",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\n## Setup\n\nYou'll need access to a mounted Oracle DB. If you don't have one already\ninstalled, here are a few options:\n* download VirtualBox from Oracle and run one of the freely\navailable images; at the time of writing, the easiest to get started with\nat the time of writing might be _Database App Development VM_. The\nimage is quite large...\n* download and install the a version of the Oracle DB itself. Developer licenses\nare free.\n* get a free workspace at https://apex.oracle.com\n\n**Note**: if you're using the online version of APEX, compilation errors will\nnot be indicated very clearly when working in _SQL Commands_ - you will simply\nget \"Error at line XX: PL/SQL: Statement ignored\"... More insight can be\nfound using the _Object Browser_ and navigating to the object you created\n(select either _Packages_ or _Procedures_ in the dropdown menu showing _Tables_,\ndepending on what you created for the exercise). Also, when you run statements,\n\"run\" each individual `create` statement individually by selecting its text.\nAPEX does not seem to like doing too much work at once...\n\nTo work on individual problems, a nice and free way is to use SQL Developer. If \nyou don't want to use yet another IDE, you can simply copy and paste your code\ninto a terminal / command prompt connected to the database. The files are\nprepared in a way that will simply overwrite the previously compiled version.\n\n#Exercise\n\n## Step 1\n\nCompile the test suite. You can easily do that by copy / pasting (let's call\nthat _installing_ for simplicity) into your terminal connected to a mounted\nOracle database.\n\nThis will fail, complaining that there is no package called `HAMMING#`.\n\nTo fix the error create the package by installing the prepared solution stub.\nNote that you will have to re-install the package body of `UT_HAMMING#`.\n\nA few words about naming: the `#` at the end of the name signifies that this\nis a package. `UT` means _unit test_. _PL/SQL_ has a maximum identifier length\nof 30 characters, which is why you will find that many words are abbreviated.\n\nIf you've worked with PL/SQL before, you might wonder why the template is a\npackage and not simply a standalone function. That would of course also be a\npossibility, but in practice standalone procedures or functions are rarely used.\n\n## Step 2\n\nTry to run the test. You will notice that you are missing the function's\nimplementation. Create it (see the test package for examples).\n\nNote that functions have to return a value, so for now just `return null;`.\n\n## Step 3\n\nRun the test again. It should now execute, but the test will fail.\nThat's where you get to actually implement the function!\n\n## Wash, Rinse, Repeat\n\nOnly the first test is enabled at first, the others are commented out. To enable\nthem, simply delete the `--` in front of the procedure call and they'll run\nwhen you next install the test package!\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hamming#.plsql\n\n",
        "hamming#.plsql": "create or replace package hamming#\nis\n  --+--------------------------------------------------------------------------+\n  -- Computes the Hamming distance between two starnds.\n  --\n  -- @param i_first  sequence to compare\n  -- @param i_second sequence to compare\n  --\n  -- @return         Hamming distance between i_first and i_second\n  --+--------------------------------------------------------------------------+\n  function distance (\n    i_first                                       varchar2\n   ,i_second                                      varchar2\n  ) return pls_integer;\n\nend hamming#;\n/\n\ncreate or replace package body hamming#\nis\n\nend hamming#;\n/\n",
        "ut_hamming#.plsql": "create or replace package ut_hamming#\nis\n  procedure run;\nend ut_hamming#;\n/\n\ncreate or replace package body ut_hamming#\nis\n\n  procedure test (\n    i_descn                                       varchar2\n   ,i_exp                                         pls_integer\n   ,i_act                                         pls_integer\n  )\n  is\n  begin\n    if i_exp = i_act then\n      dbms_output.put_line('SUCCESS: ' || i_descn);\n    else\n      dbms_output.put_line(\n           'FAILURE: '   || i_descn\n        || ': expected ' || nvl('' || i_exp, 'null')\n        || ', but got '  || nvl('' || i_act, 'null')\n        || '!'\n      );\n    end if;\n  end test;\n\n  procedure run\n  is\n  begin\n    test('test_no_difference_between_identical_strands'                    , 0, hamming#.distance(i_first => 'A'           , i_second => 'A'           ));\n    --test('test_complete_hamming_distance_of_for_single_nucleotide_strand', 1, hamming#.distance(i_first => 'A'           , i_second => 'G'           ));\n    --test('test_complete_hamming_distance_of_for_small_strand'            , 2, hamming#.distance(i_first => 'AG'          , i_second => 'CT'          ));\n    --test('test_small_hamming_distance'                                   , 1, hamming#.distance(i_first => 'AG'          , i_second => 'AT'          ));\n    --test('test_small_hamming_distance_in_longer_strand'                  , 1, hamming#.distance(i_first => 'GGACG'       , i_second => 'GGTCG'       ));\n    --test('test_nonunique_characters_within_first_strand'                 , 1, hamming#.distance(i_first => 'AGA'         , i_second => 'AGG'         ));\n    --test('test_nonunique_characters_within_second_strand'                , 1, hamming#.distance(i_first => 'AGG'         , i_second => 'AGA'         ));\n    --test('test_large_hamming_distance'                                   , 4, hamming#.distance(i_first => 'GATACA'      , i_second => 'GCATAA'      ));\n    --test('test_hamming_distance_in_very_long_strand'                     , 9, hamming#.distance(i_first => 'GGACGGATTCTG', i_second => 'AGGACGGATTCT'));\n  exception\n    when others then\n      dbms_output.put_line('Test execution failed.');\n      dbms_output.put_line(sqlerrm);\n  end run;\n\nend ut_hamming#;\n/\n\nbegin\n  ut_hamming#.run;\nend;\n/\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "python",
      "id": "bob",
      "track": "python",
      "slug": "bob",
      "files": {
        "bob.py": "#\n# Skeleton file for the Python \"Bob\" exercise.\n#\ndef hey(what):\n\n    return\n",
        "bob_test.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nimport unittest\n\nimport bob\n\n\nclass BobTests(unittest.TestCase):\n\n    def test_stating_something(self):\n        self.assertEqual(\n            'Whatever.',\n            bob.hey('Tom-ay-to, tom-aaaah-to.')\n        )\n\n    def test_shouting(self):\n        self.assertEqual(\n            'Whoa, chill out!',\n            bob.hey('WATCH OUT!')\n        )\n\n    def test_asking_a_question(self):\n        self.assertEqual(\n            'Sure.',\n            bob.hey('Does this cryogenic chamber make me look fat?')\n        )\n\n    def test_asking_a_numeric_question(self):\n        self.assertEqual(\n            'Sure.',\n            bob.hey('You are, what, like 15?')\n        )\n\n    def test_talking_forcefully(self):\n        self.assertEqual(\n            'Whatever.',\n            bob.hey(\"Let's go make out behind the gym!\")\n        )\n\n    def test_using_acronyms_in_regular_speech(self):\n        self.assertEqual(\n            'Whatever.', bob.hey(\"It's OK if you don't want to go to the DMV.\")\n        )\n\n    def test_forceful_questions(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('WHAT THE HELL WERE YOU THINKING?')\n        )\n\n    def test_shouting_numbers(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('1, 2, 3 GO!')\n        )\n\n    def test_only_numbers(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('1, 2, 3')\n        )\n\n    def test_question_with_only_numbers(self):\n        self.assertEqual(\n            'Sure.', bob.hey('4?')\n        )\n\n    def test_shouting_with_special_characters(self):\n        self.assertEqual(\n            'Whoa, chill out!',\n            bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n        )\n\n    def test_shouting_with_umlauts(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('ÜMLÄÜTS!')\n        )\n\n    def test_calmly_speaking_with_umlauts(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('ÜMLäÜTS!')\n        )\n\n    def test_shouting_with_no_exclamation_mark(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('I HATE YOU')\n        )\n\n    def test_statement_containing_question_mark(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('Ending with ? means a question.')\n        )\n\n    def test_prattling_on(self):\n        self.assertEqual(\n            'Sure.', bob.hey(\"Wait! Hang on. Are you going to be OK?\")\n        )\n\n    def test_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', bob.hey('')\n        )\n\n    def test_prolonged_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', bob.hey('    \\t')\n        )\n\n    def test_starts_with_whitespace(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('         hmmmmmmm...')\n        )\n\n    def test_ends_with_whitespace(self):\n        self.assertEqual(\n            'Sure.', bob.hey('What if we end with whitespace?   ')\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure the solution is in the `exercism/python/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.py` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/python/bob/bob.py`.\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "ruby",
      "id": "hamming",
      "track": "ruby",
      "slug": "hamming",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\n## Step 1\n\nRun the test suite. It's in Minitest, and can be run with ruby:\n\n    $ ruby hamming_test.rb\n\nThis will fail, complaining that there is no file called `hamming`.\n\nTo fix the error create an empty file called `hamming.rb` in the same\ndirectory as the `hamming_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error.\n\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    NameError: uninitialized constant Hamming\n        hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\nWithin the first test, we are referencing a constant named `Hamming` when\nwe say `Hamming.compute('A', 'A')`. When Ruby sees a capitalized name like\n`Hamming`, it looks it up in a big huge list of all the constants it knows about,\nto see what it points to. It could point to anything, and often in Ruby we have\nconstants that point to definitions of classes or modules.\n\nWhen it looks `Hamming` up in it's list, it doesn't find anything, so we need to make\none.\n\nThere are several ways that this error message can be made to go\naway, one of which is to define a `Hamming` class.\n\nOpen up the hamming.rb file and add the following code:\n\n    class Hamming\n    end\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    NoMethodError: undefined method `compute' for #<Hamming:0x007fa531343e50>\n        hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\n\nThis time we have a `Hamming`, but we're trying tell it to `compute`, and\n`Hamming` doesn't understand that message.\n\nOpen up hamming.rb and add a method definition inside the class:\n\n    class Hamming\n      def self.compute\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    ArgumentError: wrong number of arguments (2 for 0)\n      in `compute' hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\nThe method `compute` needs to take two arguments.\n\nThese are examples of method definitions that take arguments:\n\n    def self.greet(name)\n    end\n\n    def self.drink(beverage,size)\n    end\n\nChange the `compute` method definition so it takes two arguments.\n\n## Step 5\n\nRun the test again.\n\n    1) Failure:\n    HammingTest#test_no_difference_between_identical_strands [hamming_test.rb:12]:\n    Expected: 0\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that Ruby cannot even run properly because of things like missing\nfiles or syntax errors, or referring to things that don't exist.\n\nA failure is different—when you have a failure the Ruby is running just fine,\nbut the test is expecting one outcome, but getting another.\n\nThe test is expecting the `compute` method to return the number 0. The easiest way\nto make it pass, is to simply stick the number 0 inside the method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the hamming_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rinse, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hamming.rb\n\n",
        "hamming_test.rb": "require 'minitest/autorun'\nbegin\n  require_relative 'hamming'\nrescue LoadError => e\n  puts \"\\n\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\nclass HammingTest < MiniTest::Unit::TestCase\n  def test_no_difference_between_identical_strands\n    assert_equal 0, Hamming.compute('A', 'A')\n  end\n\n  def test_complete_hamming_distance_of_for_single_nucleotide_strand\n    skip\n    assert_equal 1, Hamming.compute('A', 'G')\n  end\n\n  def test_complete_hamming_distance_of_for_small_strand\n    skip\n    assert_equal 2, Hamming.compute('AG', 'CT')\n  end\n\n  def test_small_hamming_distance\n    skip\n    assert_equal 1, Hamming.compute('AT', 'CT')\n  end\n\n  def test_small_hamming_distance_in_longer_strand\n    skip\n    assert_equal 1, Hamming.compute('GGACG', 'GGTCG')\n  end\n\n  def test_nonunique_characters_within_first_strand\n    skip\n    assert_equal 1, Hamming.compute('AGA', 'AGG')\n  end\n\n  def test_nonunique_characters_within_second_strand\n    skip\n    assert_equal 1, Hamming.compute('AGG', 'AGA')\n  end\n\n  def test_large_hamming_distance\n    skip\n    assert_equal 4, Hamming.compute('GATACA', 'GCATAA')\n  end\n\n  def test_hamming_distance_in_very_long_strand\n    skip\n    assert_equal 9, Hamming.compute('GGACGGATTCTG', 'AGGACGGATTCT')\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n      cannot load such file\n\nIt's looking for a file named hamming.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named hamming.rb\nin the same directory as the hamming_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "scala",
      "id": "bob",
      "track": "scala",
      "slug": "bob",
      "files": {
        "build.sbt": "scalaVersion := \"2.10.3\"\n\nlibraryDependencies += \"org.scalatest\" % \"scalatest_2.10\" % \"2.0\" % \"test\"\n",
        "src/test/scala/bob_test.scala": "import org.scalatest._\n\nclass BobSpecs extends FlatSpec with Matchers {\n  def teenager = new Bob\n\n  it should \"respond to a statement\" in {\n    val response = teenager.hey(\"Tom-ay-to, tom-aaaah-to.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to shouting\" in {\n    pending\n    val response = teenager.hey(\"WATCH OUT!\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"respond to questions\" in {\n    pending\n    val response = teenager.hey(\"Does this cryogenic chamber make me look fat?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"allow questions to end with numbers\" in {\n    pending\n    val response = teenager.hey(\"You are what, like 15?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to talking forcefully\" in {\n    pending\n    val response = teenager.hey(\"Let's go work out at the gym!\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"allow acroynms in regular speech\" in {\n    pending\n    val response = teenager.hey(\"It's OK if you don't want to go to the DMV.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"see forceful questions as shouting\" in {\n    pending\n    val response = teenager.hey(\"WHAT THE HELL WERE YOU THINKING?\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"allow numbers when shouting\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3, GO!\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"see only numbers as speech\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to questions with only numbers\" in {\n    pending\n    val response = teenager.hey(\"4?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to shouting with no exclamation mark\" in {\n    pending\n    val response = teenager.hey(\"I HATE YOU\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"respond to statements with ? in the middle\" in {\n    pending\n    val response = teenager.hey(\"Ending with ? means a question.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to prattling on\" in {\n    pending\n    val response = teenager.hey(\"Wait! Hang on. Are you going to be OK?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to silence\" in {\n    pending\n    val response = teenager.hey(\"\")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to prolonged silence\" in {\n    pending\n    val response = teenager.hey(\"       \")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to multiple line questions\" in {\n    pending\n    val response = teenager.hey(\"\"\"\nDoes this cryogenic chamber make me look fat?\nno\"\"\")\n    response should be (\"Whatever.\")\n  }\n}\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "swift",
      "id": "leap",
      "track": "swift",
      "slug": "leap",
      "files": {
        "LeapTest.swift": "import XCTest\n\nclass LeapTest : XCTestCase {\n\n\tfunc testVanillaLeapYear() {\n\t  let year = Year(calendarYear: 1996)\n\t  XCTAssertTrue(year.isLeapYear)\n\t}\n\n\tfunc testAnyOldYear() {\n\t  let year = Year(calendarYear: 1997)\n\t  XCTAssertTrue(!year.isLeapYear)\n\t}\n\n\tfunc testCentury() {\n\t  let year = Year(calendarYear: 1900)\n\t  XCTAssertTrue(!year.isLeapYear)\n\t}\n\n\tfunc testExceptionalCentury() {\n\t  let year = Year(calendarYear: 2400)\n\t  XCTAssertTrue(year.isLeapYear)\n\t}\n\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    }
  ]
}
